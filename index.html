<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Castr Receiver - Cast & WebRTC</title>
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Cast media player */
        cast-media-player {
            width: 100%;
            height: 100%;
            --splash-image: none;
            --progress-color: rgba(66, 133, 244, 0.9);
        }

        /* WebRTC video container */
        #webrtc-container {
            display: none;
            width: 100vw;
            height: 100vh;
            background-color: #000;
        }

        #webrtc-container.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #remote-video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Status indicator */
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: #666;
        }

        .status-indicator.connected {
            background-color: #4CAF50;
            animation: pulse 2s infinite;
        }

        .status-indicator.waiting {
            background-color: #FFC107;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        #session-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
            display: none;
        }

        #session-info.active {
            display: block;
        }

        /* Debug Console Container */
        #debug-wrapper {
            position: absolute;
            top: 80px;
            left: 20px;
            right: 20px;
            z-index: 9999;
            display: none;
        }

        #debug-wrapper.active {
            display: block;
        }

        /* Debug Control Buttons */
        #debug-controls {
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 8px 8px 0 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .debug-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .debug-btn:hover {
            background: #444;
        }

        .debug-btn:active {
            background: #222;
        }

        .debug-btn.active {
            background: #007700;
            border-color: #00ff00;
        }

        /* Debug Console Overlay */
        #debug-console {
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 0 0 8px 8px;
            overflow-y: scroll;
            max-height: 500px;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #000;
        }

        /* Webkit scrollbar styling */
        #debug-console::-webkit-scrollbar {
            width: 12px;
        }

        #debug-console::-webkit-scrollbar-track {
            background: #000;
        }

        #debug-console::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 6px;
        }

        #debug-console::-webkit-scrollbar-thumb:hover {
            background: #00cc00;
        }

        #debug-console .log-entry {
            margin: 2px 0;
            word-wrap: break-word;
        }

        #debug-console .log-entry.error {
            color: #ff0000;
        }

        #debug-console .log-entry.success {
            color: #00ff00;
        }

        #debug-console .log-entry.info {
            color: #00ccff;
        }
    </style>
</head>
<body>
    <!-- Cast Framework Media Player -->
    <cast-media-player></cast-media-player>

    <!-- WebRTC Video Container -->
    <div id="webrtc-container">
        <video id="remote-video" autoplay playsinline muted></video>
    </div>

    <!-- Status Overlay -->
    <div id="status">
        <span class="status-indicator" id="status-indicator"></span>
        <span id="status-text">Castr Receiver</span>
    </div>

    <!-- Session Info (only shown in WebRTC mode) -->
    <div id="session-info">
        Mode: <span id="mode-text">Cast</span> | Session: <span id="session-id">-</span>
    </div>

    <!-- Debug Console Overlay -->
    <div id="debug-wrapper" class="active">
        <!-- Log URL Display (for viewing on phone) -->
        <div id="log-url-display" style="background: rgba(0, 255, 0, 0.9); color: #000; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: none; text-align: center; font-size: 20px; font-weight: bold; font-family: 'Courier New', monospace;">
            <div style="margin-bottom: 8px;">ðŸ“± View logs on your phone:</div>
            <div id="log-url" style="font-size: 24px; word-break: break-all;"></div>
        </div>
        <div id="debug-console"></div>
    </div>

    <script>
        // ============================================
        // Configuration
        // ============================================
        const SIGNALING_SERVER = 'wss://castr-production.up.railway.app'; // Your Railway signaling server
        const ICE_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // ============================================
        // DOM Elements
        // ============================================
        const webrtcContainer = document.getElementById('webrtc-container');
        const remoteVideo = document.getElementById('remote-video');
        const statusText = document.getElementById('status-text');
        const statusIndicator = document.getElementById('status-indicator');
        const sessionInfo = document.getElementById('session-info');
        const sessionIdDisplay = document.getElementById('session-id');
        const modeText = document.getElementById('mode-text');
        const debugConsole = document.getElementById('debug-console');

        // ============================================
        // Debug Console
        // ============================================
        const MAX_DEBUG_LINES = 500; // Increased to store more history
        const debugLines = [];
        let autoScrollEnabled = false; // Default OFF for easier reading
        let displayFrozen = false; // When true, stops updating the display
        let lastUploadTime = 0;
        const UPLOAD_INTERVAL = 10000; // Upload every 10 seconds

        function addDebugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;

            // Always store logs in memory
            debugLines.push({ text: logEntry, type });

            // Keep only last MAX_DEBUG_LINES
            while (debugLines.length > MAX_DEBUG_LINES) {
                debugLines.shift();
            }

            // Only update display if not frozen
            if (!displayFrozen) {
                updateDebugDisplay();
            }

            // Auto-upload logs periodically
            const now = Date.now();
            if (now - lastUploadTime > UPLOAD_INTERVAL) {
                lastUploadTime = now;
                uploadLogsToWeb();
            }
        }

        function updateDebugDisplay() {
            debugConsole.innerHTML = debugLines
                .map(line => `<div class="log-entry ${line.type}">${line.text}</div>`)
                .join('');

            // Auto-scroll to bottom if enabled
            if (autoScrollEnabled) {
                debugConsole.scrollTop = debugConsole.scrollHeight;
            }
        }

        // Debug Console Control Functions
        function toggleFreeze() {
            displayFrozen = !displayFrozen;
            const btn = document.getElementById('btn-freeze');

            if (displayFrozen) {
                btn.textContent = 'â–¶ï¸ RESUME';
                btn.style.background = '#770000';
                btn.style.borderColor = '#ff0000';
            } else {
                btn.textContent = 'â¸ï¸ FREEZE';
                btn.style.background = '#333';
                btn.style.borderColor = '#555';
                // Refresh display with any missed logs
                updateDebugDisplay();
                if (autoScrollEnabled) {
                    scrollToBottom();
                }
            }
        }

        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            const btn = document.getElementById('btn-autoscroll');
            btn.textContent = `Auto-Scroll: ${autoScrollEnabled ? 'ON' : 'OFF'}`;
            btn.classList.toggle('active', autoScrollEnabled);
            if (autoScrollEnabled) {
                scrollToBottom();
            }
        }

        function exportLogs() {
            // Create full log text with metadata
            const logText = [
                '='.repeat(60),
                'CASTR RECEIVER DEBUG LOGS',
                `Exported: ${new Date().toLocaleString()}`,
                `Session ID: ${sessionId || 'N/A'}`,
                `Mode: ${currentMode || 'N/A'}`,
                '='.repeat(60),
                '',
                ...debugLines.map(line => line.text)
            ].join('\n');

            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(logText).then(() => {
                    alert('âœ… Logs copied to clipboard!\n\nYou can now paste them into an email or text file.');
                }).catch(err => {
                    // Fallback: show in alert for manual copy
                    alert('Could not auto-copy. Here are your logs:\n\n' + logText);
                });
            } else {
                // Fallback for browsers without clipboard API
                alert('Logs:\n\n' + logText);
            }
        }

        function clearLogs() {
            if (confirm('Clear all debug logs?')) {
                debugLines.length = 0;
                debugConsole.innerHTML = '';
                addDebugLog('Debug console cleared', 'info');
            }
        }

        function scrollToTop() {
            debugConsole.scrollTop = 0;
        }

        function scrollToBottom() {
            debugConsole.scrollTop = debugConsole.scrollHeight;
        }

        // Upload logs to dpaste.com and display URL
        async function uploadLogsToWeb() {
            try {
                // Create log text with metadata
                const logText = [
                    '='.repeat(60),
                    'CASTR RECEIVER DEBUG LOGS',
                    `Timestamp: ${new Date().toLocaleString()}`,
                    `Session ID: ${sessionId || 'N/A'}`,
                    `Mode: ${currentMode || 'N/A'}`,
                    '='.repeat(60),
                    '',
                    ...debugLines.map(line => line.text)
                ].join('\n');

                // Upload to dpaste.com (simple paste service with API)
                const response = await fetch('https://dpaste.com/api/v2/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `content=${encodeURIComponent(logText)}&syntax=text&expiry_days=1`
                });

                if (response.ok) {
                    const url = await response.text();
                    const cleanUrl = url.trim();

                    // Display URL on screen
                    const urlDisplay = document.getElementById('log-url-display');
                    const urlText = document.getElementById('log-url');
                    urlText.textContent = cleanUrl;
                    urlDisplay.style.display = 'block';

                    originalLog('ðŸ“¤ Logs uploaded to:', cleanUrl);
                }
            } catch (error) {
                originalError('Failed to upload logs:', error);
            }
        }

        // Override console methods to also show on screen
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;

        console.log = function(...args) {
            originalLog.apply(console, args);
            addDebugLog(args.join(' '), 'info');
        };

        console.error = function(...args) {
            originalError.apply(console, args);
            addDebugLog('ERROR: ' + args.join(' '), 'error');
        };

        console.warn = function(...args) {
            originalWarn.apply(console, args);
            addDebugLog('WARN: ' + args.join(' '), 'info');
        };

        // ============================================
        // State
        // ============================================
        let currentMode = 'cast'; // 'cast' or 'webrtc'
        let ws = null;
        let peerConnection = null;
        let sessionId = null;

        // ============================================
        // Cast Framework Setup
        // ============================================
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // Cast Framework Event Listeners
        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYER_LOAD_COMPLETE,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Connected', 'connected');
                    console.log('Cast media loaded successfully');
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYING,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Playing', 'connected');
                    console.log('Cast playback started');
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.PAUSE,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Paused', 'waiting');
                    console.log('Cast playback paused');
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.ERROR,
            (event) => {
                updateStatus('Cast - Error', 'waiting');
                console.error('Cast playback error:', event.detailedErrorCode, event.error);
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.BUFFERING,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Buffering...', 'waiting');
                    console.log('Cast buffering');
                }
            }
        );

        // Intercept LOAD requests to detect WebRTC mode
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (loadRequestData) => {
                console.log('Load request:', loadRequestData);

                // Check if this is a WebRTC request
                if (loadRequestData.media && loadRequestData.media.customData) {
                    const customData = loadRequestData.media.customData;

                    // If sessionId is present, switch to WebRTC mode
                    if (customData.sessionId) {
                        console.log('WebRTC mode detected, session ID:', customData.sessionId);
                        switchToWebRTCMode(customData.sessionId, customData.signalingServer);
                        return null; // Cancel Cast playback
                    }
                }

                // Default Cast Framework handling
                if (loadRequestData.media && loadRequestData.media.contentUrl) {
                    const url = loadRequestData.media.contentUrl;
                    console.log('Loading Cast media from:', url);

                    // Set content type for MP4
                    if (!loadRequestData.media.contentType) {
                        loadRequestData.media.contentType = 'video/mp4';
                    }

                    // Enable autoplay
                    loadRequestData.autoplay = true;
                }

                return loadRequestData;
            }
        );

        // Start Cast Framework
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;
        options.maxInactivity = 3600;
        context.start(options);

        console.log('Cast Framework initialized');

        // Check URL for WebRTC session ID (for direct browser testing)
        const urlParams = new URLSearchParams(window.location.search);
        const urlSessionId = urlParams.get('sessionId');
        if (urlSessionId) {
            console.log('WebRTC session ID found in URL:', urlSessionId);
            switchToWebRTCMode(urlSessionId);
        }

        // Note: For standalone browser testing, add ?sessionId=your-session-id to the URL
        // For Chromecast mode, the receiver will detect sessionId from Cast Framework customData

        // ============================================
        // WebRTC Mode
        // ============================================
        function switchToWebRTCMode(sessionIdParam, signalingServerUrl = null) {
            currentMode = 'webrtc';
            sessionId = sessionIdParam;

            // Update UI
            webrtcContainer.classList.add('active');
            sessionInfo.classList.add('active');
            sessionIdDisplay.textContent = sessionId;
            modeText.textContent = 'WebRTC';

            // Connect to signaling server
            const serverUrl = signalingServerUrl || SIGNALING_SERVER;
            connectToSignalingServer(serverUrl);

            console.log('Switched to WebRTC mode');
        }

        function connectToSignalingServer(serverUrl) {
            updateStatus('WebRTC - Connecting...', 'waiting');

            ws = new WebSocket(serverUrl);

            ws.onopen = () => {
                console.log('Connected to signaling server');
                registerAsReceiver();
            };

            ws.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('Received message:', message.type);
                    await handleSignalingMessage(message);
                } catch (error) {
                    console.error('Error handling message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('WebRTC - Connection Error', 'waiting');
            };

            ws.onclose = () => {
                console.log('Disconnected from signaling server');
                updateStatus('WebRTC - Disconnected', 'waiting');
                // Attempt to reconnect after 3 seconds
                setTimeout(() => {
                    if (currentMode === 'webrtc') {
                        connectToSignalingServer(serverUrl);
                    }
                }, 3000);
            };
        }

        function registerAsReceiver() {
            ws.send(JSON.stringify({
                type: 'register-receiver',
                sessionId: sessionId,
                name: 'Castr WebRTC Receiver'
            }));
        }

        async function handleSignalingMessage(message) {
            switch (message.type) {
                case 'registered':
                    console.log('Registered as WebRTC receiver:', message.sessionId);
                    updateStatus('WebRTC - Waiting for sender...', 'waiting');
                    break;

                case 'offer':
                    console.log('Received offer from sender');
                    await handleOffer(message.sdp);
                    break;

                case 'ice-candidate':
                    if (message.candidate) {
                        await handleIceCandidate(message.candidate);
                    }
                    break;

                case 'peer-disconnected':
                    console.log('Sender disconnected');
                    updateStatus('WebRTC - Sender Disconnected', 'waiting');
                    closePeerConnection();
                    break;

                case 'error':
                    console.error('Signaling error:', message.message);
                    updateStatus(`WebRTC - Error: ${message.message}`, 'waiting');
                    break;
            }
        }

        async function handleOffer(sdp) {
            try {
                if (!peerConnection) {
                    createPeerConnection();
                }

                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: sdp
                }));
                console.log('Set remote description (offer)');

                // Check transceivers after setting remote description
                const transceivers = peerConnection.getTransceivers();
                console.log('Transceivers count:', transceivers.length);
                transceivers.forEach((transceiver, index) => {
                    console.log(`Transceiver ${index}:`, {
                        mid: transceiver.mid,
                        direction: transceiver.direction,
                        currentDirection: transceiver.currentDirection,
                        sender: transceiver.sender?.track?.kind,
                        receiver: transceiver.receiver?.track?.kind,
                        receiverTrackId: transceiver.receiver?.track?.id
                    });

                    // Ensure receiver is configured to receive video
                    // The sender uses sendonly, so receiver must use recvonly
                    if (transceiver.receiver?.track?.kind === 'video') {
                        console.log('Setting video transceiver direction to recvonly');
                        transceiver.direction = 'recvonly';
                    }
                });

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Created and set local description (answer)');

                // Log answer SDP to verify it includes video
                console.log('Answer SDP:', answer.sdp);
                if (answer.sdp.includes('m=video')) {
                    console.log('âœ… Video track is in answer SDP');
                    if (answer.sdp.includes('a=recvonly')) {
                        console.log('âœ… Answer has recvonly direction');
                    } else {
                        console.log('âš ï¸ Answer does not have recvonly (might be inactive or sendrecv)');
                    }
                } else {
                    console.log('âŒ No video track in answer SDP!');
                }

                ws.send(JSON.stringify({
                    type: 'answer',
                    sdp: peerConnection.localDescription.sdp
                }));

                console.log('Sent answer to sender');
                updateStatus('WebRTC - Connecting...', 'waiting');
            } catch (error) {
                console.error('Error handling offer:', error);
                updateStatus('WebRTC - Connection Failed', 'waiting');
            }
        }

        async function handleIceCandidate(candidate) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('Added ICE candidate');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function createPeerConnection() {
            console.log('Creating peer connection...');
            peerConnection = new RTCPeerConnection(ICE_SERVERS);

            // Log all peer connection events for debugging
            console.log('Setting up peer connection event handlers...');

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                    console.log('Sent ICE candidate');
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                switch (peerConnection.connectionState) {
                    case 'connected':
                        updateStatus('WebRTC - Connected', 'connected');
                        break;
                    case 'disconnected':
                        updateStatus('WebRTC - Disconnected', 'waiting');
                        break;
                    case 'failed':
                        updateStatus('WebRTC - Connection Failed', 'waiting');
                        closePeerConnection();
                        break;
                    case 'closed':
                        updateStatus('WebRTC - Closed', 'waiting');
                        break;
                }
            };

            peerConnection.ontrack = (event) => {
                console.log('ðŸŽ¯ ontrack EVENT FIRED!');
                console.log('Track kind:', event.track.kind);
                console.log('Track id:', event.track.id);
                console.log('Track label:', event.track.label);
                console.log('Track readyState:', event.track.readyState);
                console.log('Track enabled:', event.track.enabled);
                console.log('Event streams:', event.streams);
                console.log('Event streams length:', event.streams ? event.streams.length : 0);
                console.log('Event transceiver:', event.transceiver);

                if (event.streams && event.streams[0]) {
                    console.log('Using stream from event.streams[0]');
                    console.log('Stream id:', event.streams[0].id);
                    console.log('Stream active:', event.streams[0].active);
                    console.log('Stream tracks:', event.streams[0].getTracks());
                    remoteVideo.srcObject = event.streams[0];
                } else {
                    // Create a new MediaStream if streams array is empty
                    console.log('Creating new MediaStream from track');
                    const stream = new MediaStream([event.track]);
                    console.log('Created stream id:', stream.id);
                    console.log('Created stream active:', stream.active);
                    remoteVideo.srcObject = stream;
                }

                console.log('Video element srcObject set:', remoteVideo.srcObject);

                // Monitor track state changes
                event.track.onended = () => {
                    console.log('Track ended');
                };
                event.track.onmute = () => {
                    console.log('Track muted');
                };
                event.track.onunmute = () => {
                    console.log('Track unmuted');
                };

                // Explicitly play the video
                console.log('Attempting to play video...');
                remoteVideo.play().then(() => {
                    console.log('âœ… Video playing successfully');
                    console.log('Video paused:', remoteVideo.paused);
                    console.log('Video readyState:', remoteVideo.readyState);
                    console.log('Video networkState:', remoteVideo.networkState);
                    updateStatus('WebRTC - Streaming', 'connected');
                }).catch((error) => {
                    console.error('âŒ Error playing video:', error);
                    updateStatus('WebRTC - Play Error', 'waiting');
                });
            };

            // Also monitor if transceivers are created
            peerConnection.onnegotiationneeded = () => {
                console.log('Negotiation needed');
            };

            // Log when signaling state changes
            peerConnection.onsignalingstatechange = () => {
                console.log('Signaling state:', peerConnection.signalingState);
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };
        }

        function closePeerConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                remoteVideo.srcObject = null;
            }
        }

        // ============================================
        // Utility Functions
        // ============================================
        function updateStatus(text, state) {
            statusText.textContent = text;
            statusIndicator.className = 'status-indicator';
            if (state) {
                statusIndicator.classList.add(state);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.send(JSON.stringify({ type: 'disconnect' }));
                ws.close();
            }
            closePeerConnection();
        });

        console.log('Castr Hybrid Receiver initialized');
        console.log('Supports: Cast Framework & WebRTC');
    </script>
</body>
</html>
