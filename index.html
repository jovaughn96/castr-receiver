<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Castr Receiver - Cast & WebRTC</title>
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Cast media player */
        cast-media-player {
            width: 100%;
            height: 100%;
            --splash-image: none;
            --progress-color: rgba(66, 133, 244, 0.9);
        }

        /* WebRTC video container */
        #webrtc-container {
            display: none;
            width: 100vw;
            height: 100vh;
            background-color: #000;
        }

        #webrtc-container.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #remote-video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Status indicator */
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: #666;
        }

        .status-indicator.connected {
            background-color: #4CAF50;
            animation: pulse 2s infinite;
        }

        .status-indicator.waiting {
            background-color: #FFC107;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        #session-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
            display: none;
        }

        #session-info.active {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Cast Framework Media Player -->
    <cast-media-player></cast-media-player>

    <!-- WebRTC Video Container -->
    <div id="webrtc-container">
        <video id="remote-video" autoplay playsinline></video>
    </div>

    <!-- Status Overlay -->
    <div id="status">
        <span class="status-indicator" id="status-indicator"></span>
        <span id="status-text">Castr Receiver</span>
    </div>

    <!-- Session Info (only shown in WebRTC mode) -->
    <div id="session-info">
        Mode: <span id="mode-text">Cast</span> | Session: <span id="session-id">-</span>
    </div>

    <script>
        // ============================================
        // Configuration
        // ============================================
        const SIGNALING_SERVER = 'wss://castr-production.up.railway.app'; // Your Railway signaling server
        const ICE_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // ============================================
        // DOM Elements
        // ============================================
        const webrtcContainer = document.getElementById('webrtc-container');
        const remoteVideo = document.getElementById('remote-video');
        const statusText = document.getElementById('status-text');
        const statusIndicator = document.getElementById('status-indicator');
        const sessionInfo = document.getElementById('session-info');
        const sessionIdDisplay = document.getElementById('session-id');
        const modeText = document.getElementById('mode-text');

        // ============================================
        // State
        // ============================================
        let currentMode = 'cast'; // 'cast' or 'webrtc'
        let ws = null;
        let peerConnection = null;
        let sessionId = null;

        // ============================================
        // Cast Framework Setup
        // ============================================
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // Cast Framework Event Listeners
        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYER_LOAD_COMPLETE,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Connected', 'connected');
                    console.log('Cast media loaded successfully');
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYING,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Playing', 'connected');
                    console.log('Cast playback started');
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.PAUSE,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Paused', 'waiting');
                    console.log('Cast playback paused');
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.ERROR,
            (event) => {
                updateStatus('Cast - Error', 'waiting');
                console.error('Cast playback error:', event.detailedErrorCode, event.error);
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.BUFFERING,
            () => {
                if (currentMode === 'cast') {
                    updateStatus('Cast - Buffering...', 'waiting');
                    console.log('Cast buffering');
                }
            }
        );

        // Intercept LOAD requests to detect WebRTC mode
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (loadRequestData) => {
                console.log('Load request:', loadRequestData);

                // Check if this is a WebRTC request
                if (loadRequestData.media && loadRequestData.media.customData) {
                    const customData = loadRequestData.media.customData;

                    // If sessionId is present, switch to WebRTC mode
                    if (customData.sessionId) {
                        console.log('WebRTC mode detected, session ID:', customData.sessionId);
                        switchToWebRTCMode(customData.sessionId, customData.signalingServer);
                        return null; // Cancel Cast playback
                    }
                }

                // Default Cast Framework handling
                if (loadRequestData.media && loadRequestData.media.contentUrl) {
                    const url = loadRequestData.media.contentUrl;
                    console.log('Loading Cast media from:', url);

                    // Set content type for MP4
                    if (!loadRequestData.media.contentType) {
                        loadRequestData.media.contentType = 'video/mp4';
                    }

                    // Enable autoplay
                    loadRequestData.autoplay = true;
                }

                return loadRequestData;
            }
        );

        // Start Cast Framework
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;
        options.maxInactivity = 3600;
        context.start(options);

        console.log('Cast Framework initialized');

        // Check URL for WebRTC session ID (for direct browser testing)
        const urlParams = new URLSearchParams(window.location.search);
        const urlSessionId = urlParams.get('sessionId');
        if (urlSessionId) {
            console.log('WebRTC session ID found in URL:', urlSessionId);
            switchToWebRTCMode(urlSessionId);
        }

        // Note: For standalone browser testing, add ?sessionId=your-session-id to the URL
        // For Chromecast mode, the receiver will detect sessionId from Cast Framework customData

        // ============================================
        // WebRTC Mode
        // ============================================
        function switchToWebRTCMode(sessionIdParam, signalingServerUrl = null) {
            currentMode = 'webrtc';
            sessionId = sessionIdParam;

            // Update UI
            webrtcContainer.classList.add('active');
            sessionInfo.classList.add('active');
            sessionIdDisplay.textContent = sessionId;
            modeText.textContent = 'WebRTC';

            // Connect to signaling server
            const serverUrl = signalingServerUrl || SIGNALING_SERVER;
            connectToSignalingServer(serverUrl);

            console.log('Switched to WebRTC mode');
        }

        function connectToSignalingServer(serverUrl) {
            updateStatus('WebRTC - Connecting...', 'waiting');

            ws = new WebSocket(serverUrl);

            ws.onopen = () => {
                console.log('Connected to signaling server');
                registerAsReceiver();
            };

            ws.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('Received message:', message.type);
                    await handleSignalingMessage(message);
                } catch (error) {
                    console.error('Error handling message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('WebRTC - Connection Error', 'waiting');
            };

            ws.onclose = () => {
                console.log('Disconnected from signaling server');
                updateStatus('WebRTC - Disconnected', 'waiting');
                // Attempt to reconnect after 3 seconds
                setTimeout(() => {
                    if (currentMode === 'webrtc') {
                        connectToSignalingServer(serverUrl);
                    }
                }, 3000);
            };
        }

        function registerAsReceiver() {
            ws.send(JSON.stringify({
                type: 'register-receiver',
                sessionId: sessionId,
                name: 'Castr WebRTC Receiver'
            }));
        }

        async function handleSignalingMessage(message) {
            switch (message.type) {
                case 'registered':
                    console.log('Registered as WebRTC receiver:', message.sessionId);
                    updateStatus('WebRTC - Waiting for sender...', 'waiting');
                    break;

                case 'offer':
                    console.log('Received offer from sender');
                    await handleOffer(message.sdp);
                    break;

                case 'ice-candidate':
                    if (message.candidate) {
                        await handleIceCandidate(message.candidate);
                    }
                    break;

                case 'peer-disconnected':
                    console.log('Sender disconnected');
                    updateStatus('WebRTC - Sender Disconnected', 'waiting');
                    closePeerConnection();
                    break;

                case 'error':
                    console.error('Signaling error:', message.message);
                    updateStatus(`WebRTC - Error: ${message.message}`, 'waiting');
                    break;
            }
        }

        async function handleOffer(sdp) {
            try {
                if (!peerConnection) {
                    createPeerConnection();
                }

                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: sdp
                }));
                console.log('Set remote description (offer)');

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Created and set local description (answer)');

                ws.send(JSON.stringify({
                    type: 'answer',
                    sdp: peerConnection.localDescription.sdp
                }));

                console.log('Sent answer to sender');
                updateStatus('WebRTC - Connecting...', 'waiting');
            } catch (error) {
                console.error('Error handling offer:', error);
                updateStatus('WebRTC - Connection Failed', 'waiting');
            }
        }

        async function handleIceCandidate(candidate) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('Added ICE candidate');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function createPeerConnection() {
            console.log('Creating peer connection...');
            peerConnection = new RTCPeerConnection(ICE_SERVERS);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                    console.log('Sent ICE candidate');
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                switch (peerConnection.connectionState) {
                    case 'connected':
                        updateStatus('WebRTC - Connected', 'connected');
                        break;
                    case 'disconnected':
                        updateStatus('WebRTC - Disconnected', 'waiting');
                        break;
                    case 'failed':
                        updateStatus('WebRTC - Connection Failed', 'waiting');
                        closePeerConnection();
                        break;
                    case 'closed':
                        updateStatus('WebRTC - Closed', 'waiting');
                        break;
                }
            };

            peerConnection.ontrack = (event) => {
                console.log('Received remote track:', event.track.kind);
                console.log('Track readyState:', event.track.readyState);
                console.log('Event streams:', event.streams);

                if (event.streams && event.streams[0]) {
                    console.log('Setting srcObject with stream');
                    remoteVideo.srcObject = event.streams[0];
                } else {
                    // Create a new MediaStream if streams array is empty
                    console.log('Creating new MediaStream from track');
                    const stream = new MediaStream([event.track]);
                    remoteVideo.srcObject = stream;
                }

                // Explicitly play the video
                remoteVideo.play().then(() => {
                    console.log('Video playing successfully');
                    updateStatus('WebRTC - Streaming', 'connected');
                }).catch((error) => {
                    console.error('Error playing video:', error);
                    updateStatus('WebRTC - Play Error', 'waiting');
                });
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };
        }

        function closePeerConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                remoteVideo.srcObject = null;
            }
        }

        // ============================================
        // Utility Functions
        // ============================================
        function updateStatus(text, state) {
            statusText.textContent = text;
            statusIndicator.className = 'status-indicator';
            if (state) {
                statusIndicator.classList.add(state);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.send(JSON.stringify({ type: 'disconnect' }));
                ws.close();
            }
            closePeerConnection();
        });

        console.log('Castr Hybrid Receiver initialized');
        console.log('Supports: Cast Framework & WebRTC');
    </script>
</body>
</html>
