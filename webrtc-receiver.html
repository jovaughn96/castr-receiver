<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Castr WebRTC Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #video-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000;
        }

        #remote-video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: #666;
        }

        .status-indicator.connected {
            background-color: #4CAF50;
            animation: pulse 2s infinite;
        }

        .status-indicator.waiting {
            background-color: #FFC107;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        #session-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="remote-video" autoplay playsinline></video>
    </div>

    <div id="status">
        <span class="status-indicator" id="status-indicator"></span>
        <span id="status-text">Initializing...</span>
    </div>

    <div id="session-info">
        Session ID: <span id="session-id">-</span>
    </div>

    <script>
        // Configuration
        const SIGNALING_SERVER = 'ws://192.168.2.196:3000'; // Update with your server IP
        const RECEIVER_NAME = 'Castr Screen Mirror';

        // WebRTC Configuration
        const ICE_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // DOM Elements
        const remoteVideo = document.getElementById('remote-video');
        const statusText = document.getElementById('status-text');
        const statusIndicator = document.getElementById('status-indicator');
        const sessionIdDisplay = document.getElementById('session-id');

        // WebRTC and WebSocket
        let ws = null;
        let peerConnection = null;
        let sessionId = null;

        // Initialize
        init();

        function init() {
            updateStatus('Connecting to signaling server...', 'waiting');
            connectToSignalingServer();
        }

        function connectToSignalingServer() {
            ws = new WebSocket(SIGNALING_SERVER);

            ws.onopen = () => {
                console.log('Connected to signaling server');
                registerAsReceiver();
            };

            ws.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('Received message:', message.type);
                    await handleSignalingMessage(message);
                } catch (error) {
                    console.error('Error handling message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('Connection error', 'waiting');
            };

            ws.onclose = () => {
                console.log('Disconnected from signaling server');
                updateStatus('Disconnected - Reconnecting...', 'waiting');
                // Attempt to reconnect after 3 seconds
                setTimeout(() => {
                    connectToSignalingServer();
                }, 3000);
            };
        }

        function registerAsReceiver() {
            // Generate or retrieve session ID
            sessionId = getSessionIdFromURL() || generateSessionId();
            sessionIdDisplay.textContent = sessionId;

            ws.send(JSON.stringify({
                type: 'register-receiver',
                sessionId: sessionId,
                name: RECEIVER_NAME
            }));
        }

        async function handleSignalingMessage(message) {
            switch (message.type) {
                case 'registered':
                    console.log('Registered as receiver:', message.sessionId);
                    updateStatus('Waiting for sender...', 'waiting');
                    break;

                case 'offer':
                    console.log('Received offer from sender');
                    await handleOffer(message.sdp);
                    break;

                case 'ice-candidate':
                    if (message.candidate) {
                        await handleIceCandidate(message.candidate);
                    }
                    break;

                case 'peer-disconnected':
                    console.log('Sender disconnected');
                    updateStatus('Sender disconnected', 'waiting');
                    closePeerConnection();
                    break;

                case 'error':
                    console.error('Signaling error:', message.message);
                    updateStatus(`Error: ${message.message}`, 'waiting');
                    break;
            }
        }

        async function handleOffer(sdp) {
            try {
                // Create peer connection if it doesn't exist
                if (!peerConnection) {
                    createPeerConnection();
                }

                // Set remote description
                await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
                console.log('Set remote description (offer)');

                // Create answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Created and set local description (answer)');

                // Send answer to sender
                ws.send(JSON.stringify({
                    type: 'answer',
                    sdp: peerConnection.localDescription
                }));

                console.log('Sent answer to sender');
                updateStatus('Connecting to sender...', 'waiting');
            } catch (error) {
                console.error('Error handling offer:', error);
                updateStatus('Connection failed', 'waiting');
            }
        }

        async function handleIceCandidate(candidate) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('Added ICE candidate');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function createPeerConnection() {
            console.log('Creating peer connection...');
            peerConnection = new RTCPeerConnection(ICE_SERVERS);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                    console.log('Sent ICE candidate');
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                switch (peerConnection.connectionState) {
                    case 'connected':
                        updateStatus('Screen Mirror - Connected', 'connected');
                        break;
                    case 'disconnected':
                        updateStatus('Disconnected', 'waiting');
                        break;
                    case 'failed':
                        updateStatus('Connection failed', 'waiting');
                        closePeerConnection();
                        break;
                    case 'closed':
                        updateStatus('Connection closed', 'waiting');
                        break;
                }
            };

            // Handle incoming media tracks
            peerConnection.ontrack = (event) => {
                console.log('Received remote track:', event.track.kind);
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    updateStatus('Screen Mirror - Playing', 'connected');
                }
            };

            // Handle ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };
        }

        function closePeerConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                remoteVideo.srcObject = null;
            }
        }

        function updateStatus(text, state) {
            statusText.textContent = text;
            statusIndicator.className = 'status-indicator';
            if (state) {
                statusIndicator.classList.add(state);
            }
        }

        function getSessionIdFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('sessionId');
        }

        function generateSessionId() {
            return 'castr-' + Math.random().toString(36).substring(2, 15);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.send(JSON.stringify({ type: 'disconnect' }));
                ws.close();
            }
            closePeerConnection();
        });
    </script>
</body>
</html>
